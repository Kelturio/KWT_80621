FUNCTION "Scale_PT100" : Real
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      value : Int;
   END_VAR

   VAR_TEMP 
      t_norm : Real;
   END_VAR


BEGIN
	#t_norm := NORM_X(MIN := 0, VALUE := #value, MAX := "MaxAI10Bit");
	#Scale_PT100 := SCALE_X(MIN := 0.0, VALUE := #t_norm, MAX := 100.0);
END_FUNCTION

FUNCTION "ScaleValueRealToInt" : Int
TITLE = ScaleValue
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Searinox
FAMILY : AKK
NAME : '1337'
VERSION : 0.1
//Der Baustein liefert einen linearen Zusammenhang zwischen dem Wert am Eingang I1 und dem Wert am Ausgang QV. Der Ausgangswert wird durch die beiden Koordinatenpaare X1, Y1 und X2, Y2 definiert. 
   VAR_INPUT 
      VALUE : Real;   // Eingangswert
      XMIN : Real;   // Stützpunkt 1
      XMAX : Real;   // Stützpunkt 2
      YMIN : Int;   // Stützpunkt 1
      YMAX : Int;   // Stützpunkt 2
   END_VAR

   VAR_TEMP 
      t_norm : Real;
   END_VAR


BEGIN
	#t_norm := NORM_X(MIN := #XMIN, VALUE := #VALUE, MAX := #XMAX);
	#ScaleValueRealToInt := SCALE_X(MIN := #YMIN, VALUE := #t_norm, MAX := #YMAX);
END_FUNCTION

FUNCTION_BLOCK "Baustein_1"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      i_strang { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Strang
      i_beide { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Beide Pumpen
      i_err1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      i_err2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      i_run1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      i_run2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      i_tof_pt { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Time;   // Nachlaufzeit
   END_VAR

   VAR_OUTPUT 
      o_p1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Ausgang P1
      o_p2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // Ausgang P2
   END_VAR

   VAR_IN_OUT 
      io_s_p1 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // static im caller
      io_s_p2 { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // static im caller
   END_VAR

   VAR 
      i_IEC_TMR_1 {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : IEC_TIMER;
      i_IEC_TMR_2 {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'; ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : IEC_TIMER;
   END_VAR

   VAR_TEMP 
      t_err_p1 : Bool;
      t_err_p2 : Bool;
   END_VAR


BEGIN
	#t_err_p1 := #io_s_p1 AND (#i_err1 OR NOT #i_run1);
	#t_err_p2 := #io_s_p2 AND (#i_err2 OR NOT #i_run2);
	
	#io_s_p1 := #i_strang = 1 OR #t_err_p2 OR #i_beide;
	#io_s_p2 := #i_strang = 0 OR #t_err_p1 OR #i_beide;
	
	#i_IEC_TMR_1.TOF(IN := #io_s_p1,
	                 PT := #i_tof_pt,
	                 Q => #o_p1);
	#i_IEC_TMR_2.TOF(IN := #io_s_p2,
	                 PT := #i_tof_pt,
	                 Q => #o_p2);
END_FUNCTION_BLOCK

FUNCTION_BLOCK "SRTM"
TITLE = Simple runtime meter wrapper
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : 'Searinox_(Gerrit_Vogtlaender)'
VERSION : 0.1
   VAR_INPUT 
      i_CLK : Bool;   // Incoming signal, the edge of which is to be queried
      i_NR : UInt;   // Number of the operating hours counter
   END_VAR

   VAR 
      R_TRIG {OriginalPartName := 'R_TRIG_1200'; LibVersion := '1.0'} : R_TRIG;   // Detect positive signal edge
      F_TRIG {OriginalPartName := 'F_TRIG_1200'; LibVersion := '1.0'} : F_TRIG;   // Detect negative signal edge
      RTM_MODE : "RTM_MODE";   // Job IDs
      s_MODE : Byte;   // Job ID
      s_PV : DInt;   // New value for the operating hours counter
      s_CQ : Bool;   // Status of the operating hours counter (1: running)
      s_RET_VAL : Int;   // If an error occurs while the instruction is being executed, the return value contains an error code.
      s_CV : DInt;   // Current value of the operating hours counter
   END_VAR

   VAR_TEMP 
      t_R_TRIG_Q : Bool;   // Result of positive edge evaluation
      t_F_TRIG_Q : Bool;   // Result of negative edge evaluation
   END_VAR


BEGIN
	#R_TRIG(CLK := #i_CLK,
	        Q => #t_R_TRIG_Q);
	#F_TRIG(CLK := #i_CLK,
	        Q => #t_F_TRIG_Q);
	
	IF #t_R_TRIG_Q THEN
	    #s_MODE := #RTM_MODE.START;
	ELSIF #t_F_TRIG_Q THEN
	    #s_MODE := #RTM_MODE.STOP;
	ELSE
	    #s_MODE := #RTM_MODE.FETCH;
	END_IF;
	
	#s_RET_VAL := RTM(NR := #i_NR,
	                  MODE := #s_MODE,
	                  PV := #s_PV,
	                  CQ => #s_CQ,
	                  CV => #s_CV);
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "Hebeanlage"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      Strang : Bool;
      Motorschutzschalter_H1 : Bool;
      Motorschutzschalter_H2 : Bool;
      "H1 Klappe geöffnet" : Bool;
      "H2 Klappe geöffnet" : Bool;
      "Behälter Trockenlaufschutz" : Bool;
      "Behälter Pumpe ein" : Bool;
      "Behälter Pumpe aus" : Bool;
      "Behälter Überlauf" : Bool;
      "H1 Differenzdruck" : Int;
      "H2 Differenzdruck" : Int;
   END_VAR

   VAR_OUTPUT 
      "Hebeanlage 1 öffnen" : Bool;
      "Hebeanlage 2 öffnen" : Bool;
      Pumpe_H1 : Bool;
      Pumpe_H2 : Bool;
      H1_Durchflußmenge : Int;
      H2_Durchflußmenge : Int;
   END_VAR

   VAR 
      s_P1 : Bool;
      s_P2 : Bool;
      s_Nachlaufzeit : Time := T#10S;
      Baustein_1 : "Baustein_1";
   END_VAR

   VAR_TEMP 
      t_err_P1 : Bool;
      t_err_P2 : Bool;
   END_VAR


BEGIN
	#Baustein_1(i_strang := #Strang,
	            i_beide := "AlwaysFALSE",
	            i_err1 := #Motorschutzschalter_H1,
	            i_err2 := #Motorschutzschalter_H2,
	            i_run1 := "AlwaysTRUE",
	            i_run2 := "AlwaysTRUE",
	            i_tof_pt := #s_Nachlaufzeit,
	            o_p1 => #Pumpe_H1,
	            o_p2 => #Pumpe_H2,
	            io_s_p1 := #s_P1,
	            io_s_p2 := #s_P2);
	
END_FUNCTION_BLOCK

FUNCTION "ScaleValueInt" : Int
TITLE = ScaleValue
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Searinox
FAMILY : AKK
NAME : '1337'
VERSION : 0.1
//Der Baustein liefert einen linearen Zusammenhang zwischen dem Wert am Eingang I1 und dem Wert am Ausgang QV. Der Ausgangswert wird durch die beiden Koordinatenpaare X1, Y1 und X2, Y2 definiert. 
   VAR_INPUT 
      VALUE : Int;   // Eingangswert
      XMIN : Int;   // Stützpunkt 1
      XMAX : Int;   // Stützpunkt 2
      YMIN : Int;   // Stützpunkt 1
      YMAX : Int;   // Stützpunkt 2
   END_VAR

   VAR_TEMP 
      t_norm : Real;
   END_VAR


BEGIN
	#t_norm := NORM_X(MIN := #XMIN, VALUE := #VALUE, MAX := #XMAX);
	#ScaleValueInt := SCALE_X(MIN := #YMIN, VALUE := #t_norm, MAX := #YMAX);
END_FUNCTION

DATA_BLOCK "Global-DB"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
NON_RETAIN
   VAR 
      Vorlauftemperatur : Real;
      Ruecklauftemperatur : Real;
      Auto : Bool;
   END_VAR


BEGIN
   Auto := true;

END_DATA_BLOCK

FUNCTION_BLOCK "Kuehlturmkreislauf"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      i_Strang : Bool;   // Strang
      i_Vorlauftemperatur : Real;   // Vorlauftemperatur
      i_Min : Real;
      i_Max : Real;
      i_BetriebP1 : Bool;
      i_BetriebP2 : Bool;
      i_StoerungP1 : Bool;
      i_StoerungP2 : Bool;
      i_AbsalzPulse : Bool;
   END_VAR

   VAR_OUTPUT 
      o_Pumpe3 : Bool;
      o_Pumpe4 : Bool;
      o_Ventilator1 : Bool;
      o_Ventilator2 : Bool;
      o_Ventilator1Sollwert : Int;
      o_Ventilator2Sollwert : Int;
   END_VAR

   VAR 
      s_Pumpe1 : Bool;
      s_Pumpe2 : Bool;
      s_zu_kalt : Bool;
      s_zu_warm : Bool;
      s_Sollwert : Int;
      s_Ventilator_pt : Time := T#30S;
      s_Beide_Pumpen : Bool;
      s_Nachlaufzeit : Time := T#10S;
      Baustein_1 : "Baustein_1";
      IEC_TMR_0 {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;
      IEC_TMR_1 {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;
      s_Ventilator1_ET : Time;
      s_Ventilator2_ET : Time;
      s_SET_POINT_MIN : Int := 0;
      s_SET_POINT_MAX : Int := 27648;
      s_MaxThreshold : Real := 1.0;
      IEC_TMR_2 {OriginalPartName := 'IEC_TIMER'; LibVersion := '1.0'} : IEC_TIMER;
      s_AbsalzPulsePT : Time := T#5m;
      s_AbsalzTP : Bool;
      s_AbsalzPulseET : Time;
   END_VAR


BEGIN
	#s_Beide_Pumpen := #i_Vorlauftemperatur > (#i_Max + #s_MaxThreshold) OR #s_AbsalzTP;
	
	#Baustein_1(i_strang := #i_Strang,
	            i_beide := #s_Beide_Pumpen,
	            i_err1 := #i_StoerungP1,
	            i_err2 := #i_StoerungP2,
	            i_run1 := #i_BetriebP1,
	            i_run2 := #i_BetriebP2,
	            i_tof_pt := #s_Nachlaufzeit,
	            o_p1 => #o_Pumpe3,
	            o_p2 => #o_Pumpe4,
	            io_s_p1 := #s_Pumpe1,
	            io_s_p2 := #s_Pumpe2);
	
	#IEC_TMR_0.TON(IN := #i_BetriebP1 AND NOT #s_zu_kalt,
	               PT := #s_Ventilator_pt,
	               Q => #o_Ventilator1,
	               ET => #s_Ventilator1_ET);
	
	#IEC_TMR_1.TON(IN := #i_BetriebP2 AND NOT #s_zu_kalt,
	               PT := #s_Ventilator_pt,
	               Q => #o_Ventilator2,
	               ET => #s_Ventilator2_ET);
	
	#IEC_TMR_2.TP(IN := #i_AbsalzPulse,
	              PT := #s_AbsalzPulsePT,
	              Q => #s_AbsalzTP,
	              ET => #s_AbsalzPulseET);
	
	
	#s_zu_kalt := #i_Vorlauftemperatur <= #i_Min;
	#s_zu_warm := #i_Vorlauftemperatur >= #i_Max;
	
	IF #s_zu_warm THEN
	    #s_Sollwert := #s_SET_POINT_MAX;
	ELSIF #s_zu_kalt THEN
	    #s_Sollwert := #s_SET_POINT_MIN;
	ELSE
	    #s_Sollwert := "ScaleValueRealToInt"(VALUE := #i_Vorlauftemperatur,
	                                         XMIN := #i_Min,
	                                         XMAX := #i_Max,
	                                         YMIN := #s_SET_POINT_MIN,
	                                         YMAX := #s_SET_POINT_MAX);
	END_IF;
	
	#o_Ventilator1Sollwert := #s_Sollwert;
	#o_Ventilator2Sollwert := #s_Sollwert;
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "RuntimeMeters"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Searinox
VERSION : 0.1
   VAR 
      SRTM : Array[0..9] of "SRTM";
   END_VAR

   VAR_TEMP 
      i : Int;
      t_CLK : Bool;
   END_VAR


BEGIN
	FOR #i := 0 TO 9 DO
	    CASE #i OF
	        0:
	            #t_CLK := "AlwaysTRUE";
	        1:
	            #t_CLK := "Betrieb Pumpe 1";
	        2:
	            #t_CLK := "Betrieb Pumpe 2";
	        3:
	            #t_CLK := "Betrieb Pumpe 3";
	        4:
	            #t_CLK := "Betrieb Pumpe 4";
	        5:
	            #t_CLK := "Pumpe Hebeanlage 1";
	        6:
	            #t_CLK := "Pumpe Hebeanlage 2";
	        7:
	            #t_CLK := "Ventilator 1 Betrieb";
	        8:
	            #t_CLK := "Ventilator 2 Betrieb";
	        9:
	            #t_CLK := "AlwaysFALSE";
	        ELSE
	            #t_CLK := "AlwaysFALSE";
	    END_CASE;
	    #SRTM[#i](i_CLK := #t_CLK,
	              i_NR := #i);
	END_FOR;
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "ScaleAnalogValues"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      i_Vorlauftemp : Int;
      i_Ruecklauftemp : Int;
   END_VAR

   VAR_OUTPUT 
      o_Vorlauftemp : Real;
      o_Ruecklauftemp : Real;
   END_VAR


BEGIN
	#o_Vorlauftemp := "Scale_PT100"(#i_Vorlauftemp);
	#o_Ruecklauftemp := "Scale_PT100"(#i_Ruecklauftemp);
END_FUNCTION_BLOCK

FUNCTION_BLOCK "Werkskreislauf"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      i_Strang : Bool;
      i_Betrieb1 : Bool;
      i_Betrieb2 : Bool;
      i_Stoerung1 : Bool;   // Störung
      i_Stoerung2 : Bool;   // Störung
   END_VAR

   VAR_OUTPUT 
      o_Pumpe1 : Bool;
      o_Pumpe2 : Bool;
   END_VAR

   VAR 
      s_p1 : Bool;
      s_p2 : Bool;
      s_Nachlaufzeit : Time := T#10S;
      Baustein_1 : "Baustein_1";
   END_VAR

   VAR_TEMP 
      t_err_p1 : Bool;
      t_err_p2 : Bool;
   END_VAR


BEGIN
	#Baustein_1(i_strang := #i_Strang,
	            i_beide := "AlwaysFALSE",
	            i_err1 := #i_Stoerung1,
	            i_err2 := #i_Stoerung2,
	            i_run1 := #i_Betrieb1,
	            i_run2 := #i_Betrieb2,
	            i_tof_pt := #s_Nachlaufzeit,
	            o_p1 => #o_Pumpe1,
	            o_p2 => #o_Pumpe2,
	            io_s_p1 := #s_p1,
	            io_s_p2 := #s_p2);
END_FUNCTION_BLOCK

FUNCTION_BLOCK "AlwaysRUN"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Searinox
VERSION : 0.1
   VAR 
      ScaleAnalogValues : "ScaleAnalogValues";
      RuntimeMeters : "RuntimeMeters";
   END_VAR


BEGIN
	#ScaleAnalogValues(i_Vorlauftemp := "Vorlauftemperatur",
	                   i_Ruecklauftemp := "Ruecklauftemperatur",
	                   o_Vorlauftemp => "Global-DB".Vorlauftemperatur,
	                   o_Ruecklauftemp => "Global-DB".Ruecklauftemperatur);
	
	#RuntimeMeters();
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "Auto"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR 
      s_Min : Real := 0.0;
   END_VAR
   VAR RETAIN
      s_Max : Real := 27.0;
   END_VAR
   VAR 
      Werkskreislauf : "Werkskreislauf";
      Kuehlturmkreislauf : "Kuehlturmkreislauf";
      s_MaxCapMin : Real := 0.0;
      s_MaxCapMax : Real := 100.0;
      s_MaxInitVal : Real := 27.0;
      s_MinToMaxZone : Real := 2.0;
      s_strang : Bool;
      Hebeanlage : "Hebeanlage";
   END_VAR

   VAR_TEMP 
      t_ret_val : Int;
      t_dtl_out {OriginalPartName := 'DTL'; LibVersion := '1.0'} : DTL;
   END_VAR


BEGIN
	#t_ret_val := RD_SYS_T(#t_dtl_out);
	#s_strang := #t_dtl_out.DAY MOD 2 = 0;
	
	#Werkskreislauf(i_Strang := #s_strang,
	                i_Betrieb1 := "Betrieb Pumpe 1",
	                i_Betrieb2 := "Betrieb Pumpe 2",
	                i_Stoerung1 := NOT "Störung Pumpe 1",
	                i_Stoerung2 := NOT "Störung Pumpe 2",
	                o_Pumpe1 => "Pumpe 1",
	                o_Pumpe2 => "Pumpe 2");
	
	#Kuehlturmkreislauf(i_Strang := #s_strang,
	                    i_Vorlauftemperatur := "Global-DB".Vorlauftemperatur,
	                    i_Min := #s_Min,
	                    i_Max := #s_Max,
	                    i_BetriebP1 := "Betrieb Pumpe 3",
	                    i_BetriebP2 := "Betrieb Pumpe 4",
	                    i_StoerungP1 := NOT "Motorschutzschalter Pumpe 3 OK",
	                    i_StoerungP2 := NOT "Motorschutzschalter Pumpe 4 OK",
	                    i_AbsalzPulse := "Absalzanlage Impuls",
	                    o_Pumpe3 => "Pumpe 3",
	                    o_Pumpe4 => "Pumpe 4",
	                    o_Ventilator1 => "Ventilator 1",
	                    o_Ventilator2 => "Ventilator 2",
	                    o_Ventilator1Sollwert => "Sollwert Ventilator 1",
	                    o_Ventilator2Sollwert => "Sollwert Ventilator 2");
	
	IF #s_Max < #s_MaxCapMin OR #s_Max > #s_MaxCapMax THEN
	    #s_Max := #s_MaxInitVal;
	END_IF;
	
	#s_Min := #s_Max - #s_MinToMaxZone;
	
	#Hebeanlage(Strang := #s_strang,
	            Motorschutzschalter_H1 := "Motorschutzschalter Hebeanlage 1",
	            Motorschutzschalter_H2 := "Motorschutzschalter Hebeanlage 2",
	            "H1 Klappe geöffnet" := "Hebeanlage 1 Klappe geöffnet",
	            "H2 Klappe geöffnet" := "Hebeanlage 2 Klappe geöffnet",
	            "Behälter Trockenlaufschutz" := "Behälter Hebeanlage Trockenlaufschutz",
	            "Behälter Pumpe ein" := "Behälter Hebeanlage Pumpe ein",
	            "Behälter Pumpe aus" := "Behälter Hebeanlage Pumpe aus",
	            "Behälter Überlauf" := "Behälter Hebeanlage Überlauf",
	            "H1 Differenzdruck" := "Hebeanlage 1 Differenzdruck",
	            "H2 Differenzdruck" := "Hebeanlage 2 Differenzdruck",
	            "Hebeanlage 1 öffnen" => "Hebeanlage 1 öffnen",
	            "Hebeanlage 2 öffnen" => "Hebeanlage 2 öffnen",
	            Pumpe_H1 => "Pumpe Hebeanlage 1",
	            Pumpe_H2 => "Pumpe Hebeanlage 2",
	            H1_Durchflußmenge => "Hebeanlage 1 Durchflußmenge",
	            H2_Durchflußmenge => "Hebeanlage 2 Durchflußmenge");
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "Hand"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR 
      static_Vent1SollP : Int;
      static_Vent2SollP : Int;
   END_VAR


BEGIN
	"Sollwert Ventilator 1" := "ScaleValueInt"(VALUE := #static_Vent1SollP, XMIN := 0, XMAX := 100, YMIN := 0, YMAX := 27648);
	"Sollwert Ventilator 2" := "ScaleValueInt"(VALUE := #static_Vent2SollP, XMIN := 0, XMAX := 100, YMIN := 0, YMAX := 27648);
END_FUNCTION_BLOCK

FUNCTION_BLOCK "MainInstane"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Searinox
FAMILY : AKK
VERSION : 0.1
   VAR 
      AlwaysRUN : "AlwaysRUN";
      Auto : "Auto";
      Hand : "Hand";
   END_VAR


BEGIN
	#AlwaysRUN();
	
	IF "Global-DB".Auto THEN
	    #Auto();
	ELSE
	    #Hand();
	END_IF;
	
END_FUNCTION_BLOCK

DATA_BLOCK "Main_DB"
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Searinox
FAMILY : AKK
VERSION : 0.1
NON_RETAIN
"MainInstane"

BEGIN

END_DATA_BLOCK

ORGANIZATION_BLOCK "Main"
TITLE = "Main Program Sweep (Cycle)"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1

BEGIN
	"Main_DB"();
	
END_ORGANIZATION_BLOCK

